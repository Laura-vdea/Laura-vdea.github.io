VEDA 바로가기 : `www.vedacademy.co.kr`
VEDA(한화비전 아카데미) 영상으로 확인하기 : `https://url.kr/zy9afd`
본 후기는 VEDA(한화비전 아카데미) 첫번째 학습 기록으로 작성되었습니다.
교육기간 : `2024.07.15~2024.12.16`

------- 
- 작성일 : 2024-10-19
- 작성자 : 박지우
- 수업할 때에 사용한 언어 : C/C++
- 포스팅 목적 : 13주 차시의 한화비전 베다 수업 회고록

---
![](https://velog.velcdn.com/images/laura_vdea/post/bcd5298c-6c85-409e-a633-f92e54247c85/image.png)


------

# 목차

1. [서론](#0-서론)
2. [U-Boot란 무엇인가](#1-u-boot란-무엇인가)
3. [BusyBox란 무엇인가](#2-busybox란-무엇인가)
3. [QEMU란 무엇인가](#3-qemu란-무엇인가)
4. [Yocto란 무엇인가](#4-yocto란-무엇인가)
5. [Uftrace 상세 사용법](#5-uftrace-상세-사용법)
6. [Yocto에서 빌드 후 이미지 파일 작업](#6-yocto에서-빌드-후-이미지-파일-작업)
7. [마무리](#7-마무리)

------------------------

## 0. 서론
 이번 주는 한화비전 아카데미 VEDA 과정의 13주 차 수업으로, 임베디드 시스템에서 커널 부팅 및 빌드 과정과 시스템 디버깅을 중점적으로 다루었다.  그렇기 때문에 코드를 치는 수업이 거의 없었다. 아주 재미있던 주였다.
 특히 U-Boot, BusyBox, QEMU, Yocto와 같은 임베디드 개발에서 필수적인 도구들을 학습하며, 이들을 이용해 시스템을 빌드하고 실제 하드웨어나 가상화된 환경에서 실행해보는 경험을 쌓았다. 이 과정을 통해 부트로더가 어떻게 시스템을 초기화하고 운영 체제를 로드하는지, 경량화된 리눅스 유틸리티 모음을 어떻게 활용하는지, 그리고 Yocto를 이용해 커스터마이징된 임베디드 리눅스를 어떻게 생성하는지를 직접 실습하였다.

 또한, uftrace와 같은 성능 분석 도구를 활용해 프로그램의 함수 호출 흐름을 추적하고 성능을 최적화하는 방법을 배웠다. 이를 통해 임베디드 시스템의 빌드와 성능 최적화를 위한 전반적인 과정을 이해하고, 실무에서 적용할 수 있는 능력을 키울 수 있었다.

## 1. U-Boot란 무엇인가
**U-Boot (Universal Boot Loader)** 는 임베디드 시스템에서 가장 널리 사용되는 부트로더 중 하나다. 
부트로더는 시스템이 부팅될 때 하드웨어 초기화와 운영 체제 또는 커널을 로드하는 역할을 담당한다.

- 역할 : U-Boot는 하드웨어 초기화를 수행하고, 운영 체제를 RAM에 로드한 뒤 이를 실행시킨다.
- 장점 : 다양한 아키텍처(ARM, MIPS, x86 등)를 지원하며, 네트워크 부팅, 파일 시스템 관리, 커널 패치 및 개발자 도구 등의 유연한 기능을 제공한다.

**- U-Boot 실행 과정**
  - 1차 부트로더 : 하드웨어 초기화(전원 공급, 메모리, CPU 설정 등).
  - 2차 부트로더 : 운영 체제 또는 커널을 로드.
  - 최종 단계 : 운영 체제를 실행하여 메모리 관리, 파일 시스템 초기화 등의 작업을 수행한다.

## 2. BusyBox란 무엇인가
 BusyBox는 임베디드 리눅스 시스템에서 많이 사용되는 경량화된 유틸리티 모음이다. 여러 명령어와 도구들을 단일 바이너리 파일로 제공하여 시스템 리소스를 절약할 수 있다.

- 역할 : 일반적인 리눅스 명령어들을 제공하여 파일 및 프로세스 관리, 네트워크 설정, 디버깅 등에 사용다.
- 장점 : 리눅스 시스템의 주요 명령어를 간단하게 실행할 수 있으며, 경량화된 구조로 임베디드 시스템에서 자주 사용한다.
- 대표 명령어 : ls, cp, cat, grep, init, ash 등이 포함된다.

## 3. QEMU란 무엇인가
QEMU는 하드웨어 가상화를 지원하는 오픈소스 가상 머신 에뮬레이터다. CPU, 메모리, 디스크와 같은 하드웨어를 에뮬레이트하여 다양한 아키텍처의 시스템을 시뮬레이션할 수 있다.

- 용도: 리눅스, 윈도우 등 다양한 운영 체제를 QEMU 상에서 실행할 수 있으며, 임베디드 시스템 개발 시 유용하게 사용된다.
- 특징: 에뮬레이션과 하드웨어 가상화(VT-x, AMD-V) 기능을 지원하여 고성능과 유연성을 제공한다.
- 사용법: qemu-system-arm, qemu-system-x86_64 등 다양한 명령어를 통해 아키텍처에 맞는 에뮬레이션 환경을 설정한다.

```
# QEMU 실행 예제
qemu-system-x86_64 -kernel bzImage -initrd rootfs.img -nographic -append "console=ttyS0"
```

## 4. Yocto란 무엇인가
Yocto Project는 임베디드 리눅스 시스템을 구축하기 위한 오픈소스 프로젝트다. Yocto를 사용하면 특정 하드웨어에 맞춘 리눅스 배포판을 손쉽게 빌드할 수 있다.

**- 주요 구성 요소**
  - BitBake: 패키지 빌드를 위한 빌드 시스템.
  - 레시피(Recipe): 빌드할 패키지 및 설정 정보가 담긴 파일.
  - 이미지: 최종 빌드된 파일 시스템과 커널 이미지.
  - 장점: 하드웨어에 맞는 맞춤형 임베디드 리눅스를 생성할 수 있으며, 다양한 보드 및 시스템을 지원한다.

### Yocto 빌드 명령어 예제
> bitbake core-image-minimal

## 5. Uftrace 상세 사용법
 uftrace는 프로그램의 함수 호출 흐름을 추적하고 성능 분석을 할 수 있는 도구다. C/C++ 프로그램의 실행 과정을 분석할 때 유용하게 사용할 수 있다.

- 주요 기능
  - 함수 호출 추적: 프로그램에서 호출되는 함수들을 추적하여 전체적인 함수 호출 흐름을 보여준다.
  - 시간 측정: 각 함수가 실행되는 시간을 측정하여 성능 최적화를 도와준다.

### Uftrace 사용 예제
  - uftrace record ./your_program  # 실행하면서 함수 호출 추적
  - uftrace replay                  # 기록된 함수 호출 정보 확인
  - uftrace report                  # 함수 실행 시간 보고서 확인

### uftrace.c 예제
  ```
  #include <stdio.h>

  int factorial(int n) {
      return (n <= 1 ? 1 : n * factorial(n -1));
  }

  int main() {
      int n = 0;
      scanf("%d", &n);
      printf("factorial(%d) = %d\n", n, factorial(n));
      return 0;
  }
  ```
이 코드를 컴파일한 후 uftrace로 실행하면 함수 호출 추적 및 실행 시간을 확인할 수 있다.

#### 5.1. 컴파일
uftrace는 이미 컴파일된 프로그램을 추적하기 때문에 컴파일하여 실행 가능한 바이너리 파일을 생성한다.
```
gcc -o factorial factorial.c
```

#### 5.2. uftrace를 사용한 함수 호출 추적
컴파일된 실행 파일을 uftrace로 실행하면 프로그램 내의 모든 함수 호출을 추적할 수 있다.

#### 5.2.1 함수 호출 추적
uftrace의 record 명령을 사용하여 함수 호출을 추적한다.

```
uftrace record ./factorial
```
위 명령어는 ./factorial 프로그램을 실행하면서 그 과정에서 호출된 모든 함수의 정보를 기록합니다. 프로그램이 실행되면 사용자 입력을 기다리게 되는데, 여기에 팩토리얼 계산을 위한 숫자를 입력합니다. 예를 들어 5를 입력하면, 프로그램은 factorial(5)를 계산하고 종료한다.

#### 5.2.2 기록된 데이터 확인
record 명령어를 사용하여 기록된 함수 호출 데이터를 uftrace replay 명령어로 재생해볼 수 있다.

```
uftrace replay
```
이 명령어를 실행하면 프로그램 내에서 호출된 모든 함수가 트리 구조로 표시된다.
각 함수가 호출된 순서, 중첩 호출, 실행 시간이 표시되며, 어떤 함수가 어떤 함수 안에서 호출되었는지 확인할 수 있다.

#### 5.3. 함수 호출 시간 분석
uftrace는 각 함수의 호출 시간도 측정합니다. 함수별로 실행에 걸린 시간을 report 명령어를 사용하여 확인할 수 있다.

#### 5.3.1 함수 실행 시간 보고서
```
uftrace report
```
  - DURATION: 함수가 실행되는 데 걸린 총 시간.
  - CALLS: 함수가 호출된 횟수.
  - FUNCTION: 함수 이름.
  - factorial 함수는 총 6번 호출되었고, main 함수는 1번 호출되었으며 각 함수의 실행 시간이 기록됩니다.

#### 5.4. 기타 유용한 uftrace 기능
함수 호출 세부 정보 보기: uftrace replay로 호출된 각 함수의 세부 정보를 트리 형식으로 볼 수 있다.
특정 함수 필터링: 특정 함수만 추적하고 싶다면 -F 옵션을 사용합니다.
> uftrace -F factorial ./factorial
이 명령어는 factorial 함수 호출만 추적한다.

##### -N 옵션 사용 예시
예를 들어, factorial 함수만 추적 대상에서 제외하고 싶다면 다음과 같이 사용할 수 있다.
> uftrace -N factorial ./factorial

이 명령어는 factorial 함수를 제외한 모든 함수 호출을 추적한다. 이렇게 하면 factorial 함수가 여러 번 재귀 호출되더라도 그 함수에 대한 추적을 건너뛰고 다른 함수 호출 정보만 출력한다.

**-F와 -N의 차이점**
  -F (Function Include): 지정한 함수만 추적합니다. 예: uftrace -F factorial ./factorial → factorial 함수만 추적.
  -N (Function Exclude): 지정한 함수를 제외하고 모든 함수를 추적합니다. 예: uftrace -N factorial ./factorial → factorial 
  함수는 제외하고 나머지 함수를 추적.

이를 통해 특정 함수에 대한 호출만 추적하거나, 특정 함수를 제외하고 나머지 함수를 추적하는 방식으로 uftrace를 사용할 수 있다.

##### 5.5. uftrace 종료
uftrace는 기록한 데이터를 저장하고 있기 때문에, 더 이상 기록하지 않으려면 데이터를 삭제하거나 새로운 프로그램을 기록하기 위해 uftrace clear 명령어를 사용할 수 있다.
> uftrace clear

이 명령어는 이전에 기록된 데이터를 모두 삭제한다.


## 6. Yocto에서 빌드 후 이미지 파일 작업
![](https://velog.velcdn.com/images/laura_vdea/post/a1fc4cae-45ee-47ee-a420-956a4404c4ea/image.png)

**Yocto에서 빌드 후 생성된 이미지 파일을 QEMU로 실행하는 과정**

### 6.1 이미지 파일 확인
```
azabell@azabell-Vivobook:~/qemu_images$ ls
bzImage
core-image-minimal-qemux86-64-20241016070507.rootfs.ext4
launch.sh
```

### 6.2 launch.sh 스크립트
![](https://velog.velcdn.com/images/laura_vdea/post/c64a0ed2-d0e5-46d3-9f1e-7837480b83c2/image.png)

이 스크립트는 빌드된 커널과 루트 파일 시스템을 QEMU에서 실행할 수 있다.
```
#!/bin/bash

# QEMU 실행에 사용할 파일 경로
KERNEL="/home/azabell/qemu_images/bzImage-qemux86-64.bin"
ROOTFS="/home/azabell/qemu_images/core-image-minimal-qemux86-64-20241016070507.rootfs.ext4"

# QEMU 실행
qemu-system-x86_64 -nographic \
    -kernel $KERNEL \
    -drive file=$ROOTFS,format=raw \
    -append "root=/dev/sda rw console=ttyS0"
    -netdev user,id=mynet0 -device e1000,netdev=mynet0
```
**- 상세 설명**
  - bzImage : 빌드된 커널 이미지
  - rootfs.ext4 : 루트 파일 시스템 이미지
  - qemu-system-x86_64 : x86_64 아키텍처용 QEMU 명령어
  - 이 스크립트를 실행하면 QEMU 환경에서 Yocto로 빌드된 이미지를 확인할 수 있다.


#### 부팅 모습
![](https://velog.velcdn.com/images/laura_vdea/post/b6ae146f-d3ad-47c7-b9ce-8cb59e037a80/image.png)
```
root@qemux86-64:~# uname -a
Linux qemux86-64 5.15.166-yocto-standard #1 SMP PREEMPT Fri Sep 6 17:42:25 UTC 2024 x86_64 GNU/Linux


root@qemux86-64:~# uname -r
5.15.166-yocto-standard


root@qemux86-64:~# df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/root                23.5M     18.2M      3.4M  84% /
devtmpfs                 47.2M         0     47.2M   0% /dev
tmpfs                    49.4M    104.0K     49.3M   0% /run
tmpfs                    49.4M     88.0K     49.3M   0% /var/volatile
INIT: Id "S1" respawning too fast: disabled for 5 minutes

root@qemux86-64:~# free -m
              total        used        free      shared  buff/cache   available
Mem:         101072       25524       57424         192       18124       70100
Swap:             0           0           0
```

- INIT : `ld "S1"` 에러 해결은 아래로 해결
 `vi /etc/inittab` 에서 아래를 주석처리
>  S1:12345:respawn:/bin/start_getty 115200 ttyS1 vt102

- 재시작
> init q

**[ 최종 부팅 모습 ]**
```
Poky (Yocto Project Reference Distro) 4.0.22 qemux86-64 /dev/ttyS0

qemux86-64 login: root
root@qemux86-64:~# uname -r
5.15.166-yocto-standard
root@qemux86-64:~# uname a
BusyBox v1.35.0 () multi-call binary.

Usage: uname [-amnrspvio]
root@qemux86-64:~# uname -a
Linux qemux86-64 5.15.166-yocto-standard #1 SMP PREEMPT Fri Sep 6 17:42:25 UTC 2024 x86_64 GNU/Linux
root@qemux86-64:~# df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/root                23.5M     18.2M      3.4M  84% /
devtmpfs                 47.2M         0     47.2M   0% /dev
tmpfs                    49.4M    104.0K     49.3M   0% /run
tmpfs                    49.4M    104.0K     49.3M   0% /var/volatile
root@qemux86-64:~# df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/root                23.5M     18.2M      3.4M  84% /
devtmpfs                 47.2M         0     47.2M   0% /dev
tmpfs                    49.4M    104.0K     49.3M   0% /run
tmpfs                    49.4M    104.0K     49.3M   0% /var/volatile
root@qemux86-64:~# uname -r
5.15.166-yocto-standard
root@qemux86-64:~# uname -a
Linux qemux86-64 5.15.166-yocto-standard #1 SMP PREEMPT Fri Sep 6 17:42:25 UTC 2024 x86_64 GNU/Linux
```
## 7. 마무리
이번 주 수업에서는 `U-Boot`를 통한 부트로더 설정, `BusyBox`를 활용한 경량화된 시스템 구성, 그리고 `QEMU`를 이용한 가상 환경에서의 임베디드 시스템 빌드 및 디버깅 과정을 다루었습니다. `Yocto` 프로젝트를 통해 커스터마이징된 리눅스를 빌드하고, 이를 가상 환경에서 실행해보는 과정을 통해 시스템의 작동 원리를 심도 있게 이해할 수 있었습니다. 또한, `uftrace`를 활용해 프로그램의 성능을 분석하고 최적화하는 방법을 배움으로써, 임베디드 시스템의 성능 개선에 필요한 기초를 다졌습니다.

이번 실습을 통해 임베디드 시스템의 다양한 측면을 다루며, 커널 및 파일 시스템 관리, 성능 분석 등 실무에서 자주 접하게 될 기술들을 직접적으로 경험할 수 있었습니다. 이러한 경험을 바탕으로 앞으로 더욱 복잡한 프로젝트에도 도전할 수 있는 자신감을 얻었습니다.

### ✌️ 마무리 정리
**😄 Liked** 
이번 주에는 `Yocto`를 이용해 커스터마이징된 리눅스 이미지를 직접 빌드하고, 이를 `QEMU`로 실행하여 실제 임베디드 시스템 환경을 에뮬레이션해본 경험이 매우 유익했습니다. 특히 부트로더인 `U-Boot`를 통해 하드웨어 초기화 및 운영 체제 로드 과정을 직접 다루어 볼 수 있었고, 이로 인해 시스템이 부팅되는 전체 과정을 깊이 있게 이해할 수 있었습니다.

**😄 Learned**
이번 주 학습에서 가장 중요한 부분은 `Yocto`를 이용해 특정 하드웨어에 맞춘 리눅스 배포판을 빌드하고, 이를 `QEMU`에서 실행한 경험입니다. 또한, BusyBox를 통해 임베디드 시스템에서의 필수 유틸리티들을 간단하게 실행하는 방법을 배웠고, `uftrace`를 통해 성능 분석을 직접 수행하며 함수 호출 흐름을 추적하는 법을 익힐 수 있었습니다.

**😄 Lacked**
아쉬운 점은 시스템 빌드 과정에서 발생할 수 있는 여러 문제점들을 더 깊이 다루지 못한 점입니다. 빌드 중간에 발생한 오류나 커널 빌드 최적화와 같은 고급 주제들에 대해서는 시간이 부족하여 깊이 있는 탐구가 어려웠습니다. 앞으로는 이러한 고급 주제들을 더 다뤄보고 싶습니다.

**😄 Longed for**
다음 주에는 `Yocto`와 같은 시스템 빌드 도구를 더 심도 있게 학습하고, 커스터마이징된 이미지 생성뿐만 아니라 실시간 데이터 처리나 네트워크 프로그래밍과 같은 고급 주제에도 도전하고 싶습니다. 또한, `uftrace`로 더욱 복잡한 프로그램의 성능 분석을 수행해 성능 최적화의 핵심 기법들을 직접적으로 적용해보고 싶습니다.

### ✌️ 회고 및 다짐 
 이번 주 실습을 통해 부트로더, 파일 시스템 관리, 성능 분석 등 임베디드 시스템 개발의 필수적인 기술들을 경험하면서 실제 프로젝트에서 필요한 기초 역량을 다질 수 있었습니다. 이를 바탕으로 앞으로 더욱 복잡하고 실무적인 임베디드 시스템 개발에도 자신감을 갖고 도전할 수 있을 것 같습니다. 앞으로도 이러한 학습을 꾸준히 이어가며, 임베디드 시스템과 커널 개발에 필요한 깊이 있는 지식을 쌓아나갈 계획입니다.
 
 
----------

VEDA 바로가기 : `www.vedacademy.co.kr`
VEDA(한화비전 아카데미) 영상으로 확인하기 : `https://url.kr/zy9afd`
본 후기는 VEDA(한화비전 아카데미) 첫번째 학습 기록으로 작성되었습니다.
교육기간 : `2024.07.15~2024.12.16`
