VEDA 바로가기 : `www.vedacademy.co.kr`
VEDA(한화비전 아카데미) 영상으로 확인하기 : `https://url.kr/zy9afd`
본 후기는 VEDA(한화비전 아카데미) 첫번째 학습 기록으로 작성되었습니다.
교육기간 : `2024.07.15~2024.12.16`

------- 
- 작성일 : 2024-10-13
- 작성자 : 박지우
- 수업할 때에 사용한 언어 : C/C++
- 포스팅 목적 : 12주 차시의 한화비전 베다 수업 회고록

---
![](https://velog.velcdn.com/images/laura_vdea/post/bcd5298c-6c85-409e-a633-f92e54247c85/image.png)


------

# 목차

1. [서론](#0-서론)
2. [커널 레벨에서의 GPIO 활용](#1-커널-레벨에서의-gpio-활용)
3. [커널 빌드 및 커널 패닉 해결](#2-커널-빌드-및-커널-패닉-해결)
3. [이번 주 실습의 성과](#3-이번-주-실습의-성과)
4. [메모리 페이징 이론의 상세 공부](#4-메모리-페이징-이론의-상세-공부)
5. [마무리](#5-마무리)

------------------------

## 0. 서론
 이번 주는 한화비전 아카데미 VEDA의 12주 차 수업으로, 커널 모듈을 직접 작성하고 라즈베리파이에서 커널 빌드 및 메모리 페이징 이론을 학습하는 시간을 가졌다. 주된 실습은 커널 레벨에서 GPIO 핀을 제어하는 방법과 커널 패닉 문제를 해결하는 과정이었다. 커널 모듈을 insmod, rmmod 명령어로 제어하면서 라즈베리파이와 같은 임베디드 시스템에서 커널을 빌드하고 최적화하는 방법을 배울 수 있었다.

 이번 학습에서는 커널을 직접 빌드하고, 시스템 자원 관리에 대한 실질적인 경험을 쌓는 것이 주된 목표였다. 커널 패닉을 해결하는 과정에서 운영 체제의 메모리 관리, 특히 페이징 방식의 중요성을 다시금 깨닫게 되었고, 실무에서 적용할 수 있는 여러 문제 해결 기법들을 습득할 수 있었다.

 커널 모듈 작성, 커널 빌드, 메모리 페이징 문제 해결 등 다양한 주제를 다루면서 커널 레벨에서 시스템을 어떻게 제어하고 관리할 수 있는지 깊이 이해할 수 있는 기회였다.


## 1. 커널 레벨에서의 GPIO 활용
이번 주 실습에서는 커널 모듈을 직접 작성하고, 이를 이용하여 Raspberry Pi의 GPIO를 제어하는 과정을 다뤘다. 
 기본적으로 커널 모듈(.ko)을 작성하여 `insmod`로 커널에 삽입하고, `rmmod`로 모듈을 제거하며 GPIO 핀을 제어하는 실습을 진행할 수 있었다.

#### 1.1 GPIO 모듈 작성과 설명
 먼저, gpio_app.c라는 커널 모듈을 작성하였고, 이를 통해 LED를 제어할 수 있는 코드를 구현하는 수업이 있었다. 
 이 코드는 Raspberry Pi 4의 I/O 주소를 기반으로 GPIO 제어를 수행한다.
 
```
#define GPIO_LED 589 /* LED 제어를 위한 GPIO 핀 번호 */
```
 이 코드는 LED 제어를 위한 GPIO 핀을 설정한 후, 모듈을 커널에 삽입하여 커널 공간에서 LED 상태를 제어할 수 있게 해준다. 
  insmod 명령어로 모듈을 삽입하면, 디바이스 파일을 생성하고 이를 통해 사용자가 GPIO에 접근할 수 있다.

#### 1.2 insmod와 rmmod를 통한 모듈 삽입 및 제거
**- 모듈 삽입 (`insmod`)**
 작성한 모듈을 커널에 삽입하기 위해 insmod 명령어를 사용한다. 이를 통해 GPIO LED가 커널 공간에서 제어 가능하게 된다.

```
sudo insmod gpio_app.ko
```
 이 명령어는 커널에 모듈을 삽입하고, GPIO 핀을 제어할 수 있게 한다. 이후, mknod 명령어로 /dev/gpioled 파일을 생성하여 사용자 프로그램에서 GPIO 핀을 읽고 쓸 수 있다.

**- 모듈 제거 (`rmmod`)** 
 모듈이 더 이상 필요 없을 때는 rmmod 명령어로 커널에서 모듈을 제거할 수 있다.

```
sudo rmmod gpio_app
```
 이 명령어는 커널에서 모듈을 제거하고, 사용했던 GPIO 핀을 해제또한 할 수 있다.
 

#### 1.3 커널 모듈과 유저 프로그램 간의 통신
gpio_app.c 모듈은 write() 함수를 통해 LED 상태를 제어한다. 유저 프로그램 sk_app.c에서는 /dev/gpioled 파일에 값을 쓰는 방식으로 LED를 켜고 끈다. 이를 통해 커널과 유저 공간 간의 통신이 이루어진다.

```
write(fd, "1", ㅁ0);  // LED 켜기
write(fd, "0", 0);  // LED 끄기
```
 이번 실습을 통해 커널 모듈을 작성하고, insmod와 rmmod 명령어를 사용하여 커널에서 GPIO 핀을 제어하는 방법을 이해할 수 있었다. 
 또한, 커널 모듈과 유저 프로그램 간의 통신을 통해 커널 공간과 유저 공간을 연동하는 방법도 배울 수 있었다.


#### 1.4 버튼을 활용한 LED 제어
 이번 주 실습에서 버튼을 이용하여 LED를 제어하는 모듈도 구현했다. 버튼을 눌렀을 때 LED의 상태를 변경하는 방식으로, button.c라는 커널 모듈과 button_control.c라는 사용자 프로그램을 사용하여 LED의 상태를 제어하는 방법을 다루었다. 이 방식은 커널 모듈에서 버튼 인터럽트를 처리하고, 사용자 프로그램이 신호(SIGUSR1)를 통해 버튼이 눌렸을 때 LED 상태를 토글하는 구조로 되어 있다.

##### 1.4.1 버튼 제어를 위한 커널 모듈
먼저 button.c에서 버튼 인터럽트를 처리하고, GPIO 핀을 제어하는 커널 모듈을 작성했다. 이 모듈은 라즈베리파이의 GPIO 핀을 사용하여 버튼을 눌렀을 때 발생하는 인터럽트를 감지하고, LED 상태를 제어한다.

```
static irqreturn_t switch_irq_handler(int irq, void *dev_id) {
    gpio_led_state = !gpio_led_state;
    gpio_set_value(GPIO_LED, gpio_led_state);
    printk("Switch pressed, LED state: %d\n", gpio_led_state);

    if (task) {
        memset(&siginfo, 0, sizeof(struct kernel_siginfo));
        siginfo.si_signo = SIGUSR1;
        siginfo.si_code = SI_QUEUE;
        siginfo.si_int = 1234;

        send_sig_info(SIGUSR1, &siginfo, task);
    }

    return IRQ_HANDLED;
}
```
이 코드는 스위치가 눌렸을 때 발생하는 인터럽트를 처리하는 함수이다. 버튼이 눌리면 gpio_led_state를 반전시켜 LED를 켜고 끄는 역할을 한다. 또한, 사용자 프로그램에 SIGUSR1 시그널을 보내서 LED 상태가 변경되었음을 알린다.

##### 1.4.2 사용자 프로그램을 통한 LED 상태 확인 및 제어
 사용자 프로그램 button_control.c는 커널 모듈로부터 SIGUSR1 시그널을 받아 LED 상태를 출력하고 제어하는 역할을 한다. 이 프로그램은 LED 상태를 읽고, SIGUSR1 시그널이 발생할 때마다 LED 상태를 토글하며 이를 출력한다.

```
void sig_handler(int signo) {
    if (signo == SIGUSR1) {
        printf("Received SIGUSR1: Switch pressed! Toggling LED...\n");
        led_state = !led_state;
        printf("LED state changed to: %d\n", led_state);
    }
}
```
이 함수는 커널 모듈에서 받은 SIGUSR1 시그널을 처리하는 시그널 핸들러로, LED 상태를 토글하는 역할을 한다.

##### 1.4.3 버튼 제어 실습의 전체 동작 흐름
button.c 커널 모듈이 버튼 인터럽트를 처리하고, GPIO 핀을 제어한다.
버튼이 눌리면 switch_irq_handler 함수가 호출되고, LED 상태가 반전된다.
커널 모듈은 사용자 프로그램에 SIGUSR1 시그널을 보내 LED 상태 변경을 알린다.
button_control.c는 SIGUSR1 시그널을 처리하고, LED 상태를 토글하여 콘솔에 출력한다.

##### 1.4.4 결과 확인
실행 후, 버튼을 누를 때마다 콘솔에 LED 상태가 출력된다. 아래는 LED 상태가 변경될 때마다 콘솔에 출력되는 메시지다.

```
Device opened with fd: 4
Current LED state: 0
Received SIGUSR1: Switch pressed! Toggling LED...
LED state changed to: 1
Received SIGUSR1: Switch pressed! Toggling LED...
LED state changed to: 0
```
dmesg 명령어로 확인할 수 있는 커널 로그는 다음과 같다.

```
[  217.724589] Switch pressed, LED state: 1
[  217.956697] Switch pressed, LED state: 0
```
이와 같이, 이번 실습에서는 버튼을 사용하여 커널 모듈과 사용자 프로그램 간의 통신을 통해 LED 제어를 구현하는 방법을 학습할 수 있었다.


## 2. 커널 빌드 및 커널 패닉 해결
 이번 주에는 라즈베리파이 커널을 빌드하고, 커널 패닉 문제를 해결하는 과정도 있었다. 내가 가장 궁금하던 부분이었는데 `Arm`에서 하는 것은 `Intel cpu`와는 느낌이 또 달랐다.

#### 2.1 커널 빌드 과정
커널 빌드 과정은 커널 소스를 받아 필요한 설정을 하고, 커널 이미지와 모듈들을 빌드하여 라즈베리파이 시스템에 적용하는 일련의 작업입니다. 라즈베리파이와 같은 임베디드 시스템에서는 커널을 사용자가 직접 빌드하고, 필요에 맞게 커스터마이징하여 사용할 수 있습니다. 여기에서는 라즈베리파이에서 커널을 빌드하는 구체적인 과정을 설명하겠습니다.

##### 2.1.1. 빌드 전 준비 작업
먼저, 커널 빌드 환경을 준비하기 위해 소스 코드를 초기화하고, 기존 설정이나 빌드 파일을 모두 정리하는 작업을 진행하였다. 이 작업은 커널 빌드를 할 때 발생할 수 있는 불필요한 오류를 방지하고, 클린한 환경에서 빌드를 시작할 수 있게 해준다. 이를 위해 아래 명령어들을 사용한다.

```
sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- mrproper
sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- clean
```
`ARCH=arm64` : 라즈베리파이는 ARM 아키텍처를 사용하므로, 이 플래그는 ARM64 아키텍처를 지정합니다.
`CROSS_COMPILE=aarch64-linux-gnu-` : 크로스 컴파일러를 지정하여, ARM64용으로 컴파일을 할 수 있도록 설정합니다.
`mrproper` : 기존 빌드에서 생성된 불필요한 파일을 모두 삭제하고, 소스 디렉토리를 초기화하는 명령어입니다.
`clean` : mrproper와 비슷한 역할을 하지만, 일부 설정 파일은 유지하고 컴파일된 오브젝트 파일만 삭제합니다.

##### 2.1.2. 기본 설정 파일 불러오기
커널 빌드는 수많은 설정 옵션이 존재하기 때문에, 하드웨어에 맞는 기본 설정 파일을 불러온 후 수정하는 방식으로 진행한다. 여기서는 라즈베리파이 모델에 맞는 기본 설정 파일을 불러오면 된다.

```
sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- bcm2712_defconfig
```
`bcm2712_defconfig` : 라즈베리파이 4 모델에 맞는 기본 설정 파일을 불러옵니다. 이 파일에는 라즈베리파이에서 자주 사용하는 드라이버와 기능들이 포함되어 있습니다. 불러온 설정 파일을 기반으로 커널 빌드를 위한 초기 설정이 이루어집니다.

##### 2.1.3. 커널 설정 변경 (menuconfig)
 이후, 시스템에 필요한 커널 옵션을 설정하기 위해 menuconfig 명령어를 실행한다. 이 단계에서 추가적으로 필요한 모듈을 활성화하거나, 필요 없는 기능을 비활성화할 수 있었다.

```
sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig
```
`menuconfig`는 터미널 상에서 메뉴 기반으로 커널 옵션을 설정할 수 있게 해주는 유용한 도구입니다. 여기서 필요한 드라이버나 기능들을 켜거나 끌 수 있으며, 예를 들어 특정 GPIO 핀을 제어하기 위한 설정이나 추가 드라이버 설치 등을 수행할 수 있습니다. 라즈베리파이의 하드웨어와 연동할 수 있는 추가 기능들을 활성화할 수 있습니다.

##### 2.1.4. 커널 및 모듈 빌드
설정을 완료한 후에는 실제로 커널과 모듈을 빌드한다. 이 단계가 가장 중요하며, 커널 이미지 파일(`Image`), `모듈`, 그리고 장치 트리 파일(`dtb`)을 생성한다.

```
sudo make -j$(nproc) ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image modules dtbs
```
`-j$(nproc)` : 현재 사용 가능한 CPU 코어 수에 맞춰 병렬로 빌드 작업을 진행합니다. 빌드 속도를 높여주는 옵션입니다.
`Image` : 커널 이미지 파일을 생성하는 명령어입니다.
`modules` : 커널 모듈들을 빌드하여 나중에 커널에서 동적으로 로드할 수 있게 합니다.
`dtbs` : 장치 트리 파일을 생성합니다. 라즈베리파이와 같은 임베디드 시스템에서 하드웨어 구성을 나타내는 정보가 담겨 있습니다.

##### 2.1.5. 모듈 설치 및 커널 이미지 복사
 커널 빌드가 완료되면, 빌드된 커널 모듈을 시스템에 설치하고, 새롭게 빌드한 커널 이미지를 라즈베리파이의 부팅 디스크로 복사하는 과정이다.

```
sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- modules_install INSTALL_MOD_PATH=/media/azabell/rootfs
```
`modules_install`: 빌드된 커널 모듈을 지정한 경로(/media/azabell/rootfs)에 설치합니다. 이 경로는 라즈베리파이의 루트 파일 시스템이 마운트된 디렉토리입니다.

```
KERNEL=kernel_2712
file arch/arm64/boot/Image
```
커널 이미지 파일은 arch/arm64/boot/Image에 생성됩니다. 이 파일은 라즈베리파이의 부팅 시 사용되는 커널 파일입니다.

```
sudo cp arch/arm64/boot/Image /media/azabell/bootfs/$KERNEL.img
sudo cp arch/arm64/boot/dts/broadcom/*.dtb /media/azabell/bootfs/
sudo cp arch/arm64/boot/dts/overlays/*.dtb* /media/azabell/bootfs/overlays/
sudo cp arch/arm64/boot/dts/overlays/README /media/azabell/bootfs/overlays/
```
cp 명령어를 통해 빌드된 커널 이미지 파일을 라즈베리파이의 /boot 디렉토리로 복사합니다. dtb 및 dtbo 파일도 함께 복사하여 하드웨어 구성 파일을 함께 설정합니다.

##### 2.1.6. 마무리
 모든 파일을 복사한 후에는 /media/azabell/bootfs와 /media/azabell/rootfs를 언마운트한다. 이를 통해 라즈베리파이의 부팅 장치에 커널 이미지와 모듈들이 모두 적용되었음을 확인할 수 있다.

```
sudo umount /media/azabell/bootfs
sudo umount /media/azabell/rootfs
```

##### 결론
 이 과정을 통해 커널을 직접 빌드하고, 커널 이미지와 모듈을 라즈베리파이 시스템에 적용할 수 있었다. 커널 설정 변경(`menuconfig`), 커널 및 모듈 빌드, 그리고 커널 이미지를 시스템에 적용하는 과정을 통해 임베디드 시스템에서 커널 빌드를 어떻게 수행하는지 실습할 수 있었으며, 이를 통해 실무에서 커널 커스터마이징 능력을 향상시킬 수 있었다.

#### 2.2 커널 패닉 문제 해결
![](https://velog.velcdn.com/images/laura_vdea/post/b58760ce-a0f0-47d1-9b29-2ca4a739e7f0/image.png)

 내가 빌드를 하고 옮긴 당시에 계속하여서 연신 커널 패닉 버그 문제가 발생하였다. 커널 패닉 문제는 라즈베리파이의 메모리 페이지 크기 설정(`16KB`)을 `4KB`로 조정하여 해결할 수 있었다. 
 페이징 메모리 관리 시스템에서 페이지 크기가 너무 크면 커널 패닉이 발생할 수 있으며 이를 해결하기 위해서 커널의 페이지 크기를 변경해야 할 필요가 있었다. 커널을 빌드하기 전에 환경설정을 미리 하는 것이 있는데, `menuconfig`를 활용하였다.

 메모리 페이지 크기를 조정한 후 커널을 다시 빌드하고 적용함으로써 커널 패닉 문제를 해결할 수 있었고 결과적으로 빌드에 성공하였다.

#### 2.3 메모리 페이징 이론
 페이징은 운영 체제가 물리 메모리를 일정 크기의 페이지로 나누어 관리하는 방식이다. 각 페이지의 크기는 시스템의 성능과 안정성에 영향을 미치며, 페이지 크기가 너무 크면 메모리 사용이 비효율적일 수 있고, 커널 패닉과 같은 문제가 발생할 수 있다. 
 이번 실습에서는 이러한 문제를 해결하기 위해 페이지 크기를 4KB로 줄였으며 이번 시행착오 덕분에 면접에서 이야기할 거리가 생긴 것 같다.

## 3. 이번 주 실습의 성과
 이번 주 실습을 통해 다음과 같은 중요한 교훈을 얻을 수 있었다.

**1. 커널 모듈 개발 경험**
 커널 모듈을 직접 작성하고, 이를 통해 하드웨어를 제어하는 과정을 경험할 수 있었으며 `insmod`와 `rmmod`를 통해 커널 공간에서 GPIO 제어를 수행한 것이 주된 수업이었다.

**커널 빌드 및 설정 조정**
 커널을 직접 빌드하고, `menuconfig`를 통해 설정을 변경하여 시스템을 최적화하는 방법을 익혔다. 커널 패닉 문제를 해결하면서 메모리 관리의 중요성을 다시 한번 깨달을 수 있었다. 이번을 계기로 메모리 관리가 진짜 무엇인지 좀 더 체감이 될 수 있었던 기회가 되어주었다.

**실무에 적용 가능한 경험**
 이번 실습을 통해 임베디드 시스템 개발에 필요한 기초 기술들을 쌓을 수 있었으며, 이를 바탕으로 실무에서의 문제 해결 능력을 키울 수 있었다.


## 4. 메모리 페이징 이론의 상세 공부
이번 주 실습에서 커널 패닉 문제를 겪으면서 메모리 페이징에 대해 더 깊이 공부할 필요성을 느꼈다. 운영 체제의 메모리 관리에서 중요한 페이징 방식의 원리와 시스템 성능에 미치는 영향이 직접적으로 어떤 것인지 궁금해졌기 때문이다. 대학교 때 배운 페이징 교체 이론은 대충 머릿속에 남아 있었지만, 이번 기회에 커널 패닉 문제를 해결하기 위해 다시 공부하게 되었다.

#### 4.1 페이징이란 무엇인가?
 페이징은 운영 체제가 메모리를 작은 고정된 크기(페이지)로 나누어 가상 메모리와 물리 메모리를 연결하는 방식이다. 이때 물리 메모리와 가상 메모리는 다음과 같이 나뉜다.

`가상 메모리` : 프로그램이 사용하는 논리적인 메모리 주소 공간. CPU는 이 논리적인 주소를 사용해 메모리에 접근하려고 한다.
`물리 메모리` : 실제로 하드웨어가 가지고 있는 메모리 공간. CPU는 직접적으로 물리 메모리에 접근하지 않고, 가상 메모리 주소를 통해 접근한다.
이때 가상 메모리와 물리 메모리 사이에 페이지 테이블이 존재한다. 페이지 테이블은 가상 메모리 주소를 물리 메모리 주소로 변환해주는 역할을 한다.

```
+------------------+     +--------------------+     +-------------------+
|  가상 메모리     	 |     |     페이지 테이블    |     |    물리 메모리      |
|                   |     |  (매핑 정보 저장)   |     |                   |
|  [페이지 0]        |---> |[페이지 0 -> 프레임 5] |   |    [프레임 0]       |
|  [페이지 1]        |---> |[페이지 1 -> 프레임 2] |   |    [프레임 1]       |
|  [페이지 2]        |---> |[페이지 2 -> 프레임 7] |   |    [프레임 2]       |
|                   |    |                    |    |                   |
+------------------+     +--------------------+     +-------------------+
```
`페이지` : 가상 메모리를 일정한 크기로 나눈 블록. 예를 들어, 페이지 크기가 4KB라면 가상 메모리 공간은 4KB 단위로 나뉜다.
`프레임` : 물리 메모리에서 페이지가 할당되는 공간. 프레임은 페이지와 같은 크기로 나뉜다.
이 구조 덕분에 프로그램은 연속된 메모리 공간을 사용하는 것처럼 보이지만, 실제로는 물리 메모리의 여러 위치에 나뉘어 저장된다.

#### 4.2 페이지 테이블과 페이징의 역할
운영 체제는 페이지 테이블을 사용해 각 페이지가 물리 메모리의 어느 위치에 저장되는지 기록한다. 페이지 테이블은 CPU가 가상 메모리 주소를 물리 메모리 주소로 변환할 수 있도록 돕는다.
```
가상 주소 -> 페이지 번호 | 오프셋
               ↓
페이지 번호 -> 페이지 테이블 조회
               ↓
페이지 테이블 -> 물리 주소(프레임 번호) | 오프셋
               ↓
물리 주소로 메모리 접근
```
`가상 주소` : CPU가 접근하려는 논리적 주소는 페이지 번호와 오프셋으로 나뉜다. 페이지 번호는 어느 페이지에 속하는지 나타내고, 오프셋은 페이지 내의 정확한 위치를 가리킨다.
`페이지 테이블` : 페이지 번호에 따라 해당 페이지가 물리 메모리에서 어느 프레임에 저장되어 있는지 조회한다.
`물리 주소` : 페이지 테이블이 제공하는 프레임 번호와 오프셋을 사용해 실제 물리 메모리에서 데이터를 읽는다.
페이지 테이블 덕분에 프로그램은 자신이 사용하는 메모리가 연속적이라고 인식할 수 있다. 실제로는 여러 다른 위치에 흩어져 있더라도, 페이지 테이블이 가상 메모리와 물리 메모리 사이의 변환을 도와준다.

#### 4.3 페이지 크기의 중요성
페이지 크기는 메모리 시스템의 성능과 효율에 큰 영향을 미친다.

```
+---------------------------+
|  페이지 크기: 4KB          |  
+---------------------------+
| 장점:                      |
|  - 작은 크기 덕분에 세밀한    |
|    메모리 할당 가능          |
| 단점:                     |
|  - 많은 페이지 테이블 엔트리| |
|    를 관리해야 함           |
+---------------------------+
  
+---------------------------+
|  페이지 크기: 16KB           |  
+---------------------------+
| 장점:                      |
|  - 페이지 테이블 관리 비용     |
|    감소                    |
| 단점:                      |
|  - 메모리 낭비 증가           |
+---------------------------+
```
페이지 크기가 작을수록 메모리 할당의 세분화가 가능해져서 메모리 낭비가 적지만, 그만큼 더 많은 페이지 테이블 엔트리를 관리해야 하기 때문에 관리 비용이 증가한다. 
반대로 페이지 크기가 커질수록 페이지 테이블 관리 비용은 줄어들지만, 사용하지 않는 메모리 공간이 많아져 메모리 낭비가 발생할 수 있다는 것을 배울 수 있었다.

이번에 커널 패닉 문제를 해결할 때는 16KB 페이지 크기가 시스템에 부담을 주어 발생한 문제였고, 이를 4KB로 조정해 해결할 수 있었다.

#### 4.4 페이징 메모리와 커널 패닉의 관계
 메모리 페이징이 잘못 관리되면 커널 패닉과 같은 심각한 시스템 오류가 발생할 수 있다. 커널 패닉은 시스템이 더 이상 정상적으로 동작할 수 없을 때 운영 체제가 시스템을 중단시키는 방법이다. 페이징이 정상적으로 관리되지 않거나, 페이지 테이블이 제대로 동작하지 않으면 운영 체제는 시스템을 보호하기 위해 커널 패닉을 발생시킨다.

이번 실습에서 커널 패닉이 발생했을 때, 페이지 크기를 4KB로 조정함으로써 시스템의 안정성을 확보할 수 있었다.

#### 4.5 메모리 페이징의 실무 활용
페이징 메커니즘은 모든 현대적인 운영 체제에서 필수적인 메모리 관리 기법이다. 특히 제한된 자원을 사용하는 임베디드 시스템에서는 메모리 관리가 매우 중요하다. 페이지 크기 설정은 메모리 성능과 시스템 안정성에 직접적인 영향을 미치며, 페이지 테이블이 시스템 성능을 좌우할 수 있기 때문이다.

이번 실습을 통해 페이징 메커니즘의 중요성을 다시금 깨달았고, 이를 앞으로의 임베디드 시스템 개발에 적용할 수 있을 것이다. 페이지 크기와 메모리 관리 방식에 대한 이해는 시스템 성능을 최적화하고 안정성을 유지하는 데 중요한 역할을 할 것이다.

## 5. 마무리
 이번 주 수업에서는 커널 레벨에서의 GPIO 제어와 커널 빌드, 메모리 페이징 이론까지 다양한 주제를 다루었습니다. 각 실습을 통해 하드웨어와 소프트웨어가 어떻게 연동되는지에 대한 이해를 높이고, 커널 레벨에서 시스템 자원을 관리하는 방법을 체험할 수 있었습니다.

이번 주 실습을 통해 커널 모듈 개발, 커널 빌드 과정, 그리고 메모리 관리와 관련된 중요한 기술들을 배우면서 임베디드 시스템 개발의 기초를 다질 수 있었습니다. 이를 통해 실무에서도 바로 적용할 수 있는 경험을 쌓을 수 있었으며, 앞으로 더 큰 프로젝트에 도전하는 데 있어 자신감을 얻었습니다.

### ✌️ 마무리 정리
**😄 Liked**
이번 주에는 커널 모듈을 작성하고, 이를 통해 GPIO 핀을 제어하는 과정을 직접 경험한 점이 가장 인상 깊었습니다. 특히 insmod와 rmmod 명령어를 통해 커널에서 모듈을 동적으로 관리할 수 있었던 경험은 매우 유익했습니다. 또한 커널 빌드 과정에서 menuconfig를 사용하여 커널 설정을 변경하고, 커널 패닉 문제를 해결하는 과정에서 실무에서 자주 마주할 수 있는 문제 해결 능력을 키울 수 있었습니다.

**😄 Learned**
이번 주 학습의 핵심은 커널 모듈을 작성하고, 이를 통해 하드웨어를 직접 제어하는 경험을 쌓았다는 점입니다. 특히 GPIO 핀을 커널 레벨에서 제어하고, 메모리 페이징 문제를 해결하면서 운영 체제의 메모리 관리 방식에 대한 심도 있는 이해를 할 수 있었습니다. 또한 페이징 메모리 관리의 중요성을 깨닫고, 메모리 크기 조정을 통해 시스템 안정성을 확보하는 방법을 배울 수 있었습니다.

**😄 Lacked**
아쉬운 점은 커널 내부 구조와 CPU 스케줄링, 인터럽트 관리 등 심화된 커널 동작을 다룰 시간이 부족했다는 것입니다. 다음 실습에서는 이러한 고급 주제들을 더 깊이 다루어 커널과 운영 체제의 전반적인 동작을 더욱 체계적으로 학습할 계획입니다.

**😄 Longed for**
다음 주에는 이번 주에 배운 커널 모듈 개발과 메모리 관리 기술을 바탕으로 더 큰 프로젝트에 도전하고 싶습니다.~~(마음은 이렇지만 현실에서의 시간은 한없이 부족하다.)~~ 특히 라즈베리파이에서 커널 모듈을 활용한 고급 하드웨어 제어와, 멀티태스킹 및 동시성 제어와 같은 커널 내부 기법들을 더욱 심도 있게 다루고 싶습니다. 또한, 이를 기반으로 네트워크 프로그래밍과 실시간 데이터 처리 기술을 응용한 프로젝트에도 도전하고 싶습니다.

**✌️ 회고 및 다짐**
이번 주 실습을 통해 커널 모듈 개발과 메모리 관리, 그리고 커널 빌드와 관련된 실질적인 경험을 쌓을 수 있었습니다. 이를 통해 커널 패닉 문제를 해결하며 운영 체제의 메모리 관리 기법에 대한 이해를 높일 수 있었고, 실무에서 필요한 기술을 직접 체험할 수 있었습니다.

앞으로도 꾸준히 학습하고 실습하며, 커널 개발과 임베디드 시스템 개발에 필요한 핵심 기술들을 더욱 깊이 있게 학습할 계획입니다.

----------

VEDA 바로가기 : `www.vedacademy.co.kr`
VEDA(한화비전 아카데미) 영상으로 확인하기 : `https://url.kr/zy9afd`
본 후기는 VEDA(한화비전 아카데미) 첫번째 학습 기록으로 작성되었습니다.
교육기간 : `2024.07.15~2024.12.16`

